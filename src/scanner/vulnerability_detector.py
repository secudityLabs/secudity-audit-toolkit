"""
Secudity Vulnerability Detector
Automated detection of common smart contract vulnerabilities
"""

import re
from typing import List, Dict, Any
from dataclasses import dataclass
from enum import Enum


class Severity(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "Critical"
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"
    INFORMATIONAL = "Informational"


@dataclass
class Vulnerability:
    """Data class for vulnerability findings"""
    name: str
    severity: Severity
    description: str
    location: str
    line_number: int
    code_snippet: str
    recommendation: str
    reference: str = ""


class VulnerabilityDetector:
    """Main vulnerability detection engine"""
    
    def __init__(self, contract_code: str, contract_path: str):
        self.contract_code = contract_code
        self.contract_path = contract_path
        self.lines = contract_code.split('\n')
        self.vulnerabilities: List[Vulnerability] = []
    
    def detect_all(self) -> List[Vulnerability]:
        """Run all vulnerability checks"""
        self.check_reentrancy()
        self.check_tx_origin()
        self.check_unchecked_calls()
        self.check_access_control()
        self.check_timestamp_dependence()
        self.check_delegatecall()
        self.check_selfdestruct()
        self.check_locked_ether()
        self.check_integer_overflow()
        
        return self.vulnerabilities
    
    def check_reentrancy(self):
        """Detect potential reentrancy vulnerabilities"""
        # Pattern: external call followed by state change
        for i, line in enumerate(self.lines):
            # Check for external calls
            if '.call{' in line or '.transfer(' in line or '.send(' in line:
                # Look ahead for state changes
                for j in range(i + 1, min(i + 10, len(self.lines))):
                    next_line = self.lines[j]
                    
                    # Check if state is modified after external call
                    if ('=' in next_line and 
                        not next_line.strip().startswith('//') and
                        ('balances[' in next_line or 'balance' in next_line)):
                        
                        self.vulnerabilities.append(Vulnerability(
                            name="Reentrancy",
                            severity=Severity.CRITICAL,
                            description="Potential reentrancy vulnerability detected. "
                                      "External call is made before state variables are updated.",
                            location=self.contract_path,
                            line_number=i + 1,
                            code_snippet=self._get_code_snippet(i, 5),
                            recommendation="Follow the Checks-Effects-Interactions pattern. "
                                         "Update state variables before making external calls. "
                                         "Consider using ReentrancyGuard from OpenZeppelin.",
                            reference="https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/"
                        ))
                        break
    
    def check_tx_origin(self):
        """Detect tx.origin usage for authentication"""
        for i, line in enumerate(self.lines):
            if 'tx.origin' in line and not line.strip().startswith('//'):
                # Check if it's used for authentication
                if ('require' in line or 'if' in line) and ('==' in line or '!=' in line):
                    self.vulnerabilities.append(Vulnerability(
                        name="tx.origin Authentication",
                        severity=Severity.HIGH,
                        description="Using tx.origin for authentication is dangerous and can "
                                  "lead to phishing attacks.",
                        location=self.contract_path,
                        line_number=i + 1,
                        code_snippet=self._get_code_snippet(i, 3),
                        recommendation="Use msg.sender instead of tx.origin for authentication. "
                                     "tx.origin should rarely be used.",
                        reference="https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/tx-origin/"
                    ))
    
    def check_unchecked_calls(self):
        """Detect unchecked low-level calls"""
        for i, line in enumerate(self.lines):
            # Look for low-level calls without checking return value
            if '.call(' in line or '.delegatecall(' in line:
                # Check if result is captured and checked
                if not '(bool' in line and not 'require(' in self.lines[i] and not 'if' in self.lines[i]:
                    # Check next few lines for require/if checking success
                    checked = False
                    for j in range(i, min(i + 3, len(self.lines))):
                        if 'require(' in self.lines[j] or 'if(' in self.lines[j]:
                            checked = True
                            break
                    
                    if not checked:
                        self.vulnerabilities.append(Vulnerability(
                            name="Unchecked Call Return Value",
                            severity=Severity.HIGH,
                            description="Low-level call return value is not checked. "
                                      "Silent failures can occur.",
                            location=self.contract_path,
                            line_number=i + 1,
                            code_snippet=self._get_code_snippet(i, 3),
                            recommendation="Always check the return value of low-level calls. "
                                         "Use require() or handle the failure case explicitly.",
                            reference="https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/unchecked-call-return-values/"
                        ))
    
    def check_access_control(self):
        """Detect missing access control"""
        # Find critical functions without modifiers
        critical_keywords = ['owner', 'admin', 'withdraw', 'transfer', 'destroy', 'kill', 'pause']
        
        for i, line in enumerate(self.lines):
            if 'function' in line and 'public' in line:
                function_name = self._extract_function_name(line)
                
                # Check if it's a critical function
                is_critical = any(keyword in function_name.lower() for keyword in critical_keywords)
                
                if is_critical:
                    # Check for access control modifiers
                    has_modifier = False
                    modifiers = ['onlyOwner', 'onlyAdmin', 'require(msg.sender']
                    
                    # Check current line and next few lines
                    for j in range(i, min(i + 5, len(self.lines))):
                        if any(mod in self.lines[j] for mod in modifiers):
                            has_modifier = True
                            break
                    
                    if not has_modifier:
                        self.vulnerabilities.append(Vulnerability(
                            name="Missing Access Control",
                            severity=Severity.CRITICAL,
                            description=f"Critical function '{function_name}' lacks access control. "
                                      f"Anyone can call this function.",
                            location=self.contract_path,
                            line_number=i + 1,
                            code_snippet=self._get_code_snippet(i, 5),
                            recommendation="Add access control modifiers like 'onlyOwner' or "
                                         "use require() to check msg.sender permissions.",
                            reference="https://docs.openzeppelin.com/contracts/4.x/access-control"
                        ))
    
    def check_timestamp_dependence(self):
        """Detect dangerous timestamp usage"""
        for i, line in enumerate(self.lines):
            if 'block.timestamp' in line or 'now' in line:
                # Check if used in critical logic
                if ('require' in line or 'if' in line or '==' in line or 
                    '<' in line or '>' in line or '%' in line):
                    
                    self.vulnerabilities.append(Vulnerability(
                        name="Timestamp Dependence",
                        severity=Severity.MEDIUM,
                        description="Contract logic depends on block.timestamp which can be "
                                  "manipulated by miners within a ~15 second window.",
                        location=self.contract_path,
                        line_number=i + 1,
                        code_snippet=self._get_code_snippet(i, 3),
                        recommendation="Avoid using block.timestamp for critical logic, "
                                     "especially for randomness. Use block.number or oracles instead.",
                        reference="https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/timestamp-dependence/"
                    ))
    
    def check_delegatecall(self):
        """Detect unsafe delegatecall usage"""
        for i, line in enumerate(self.lines):
            if 'delegatecall' in line and not line.strip().startswith('//'):
                self.vulnerabilities.append(Vulnerability(
                    name="Delegatecall to Untrusted Contract",
                    severity=Severity.CRITICAL,
                    description="delegatecall executes code in the context of the calling contract. "
                              "If called on an untrusted contract, it can modify state variables.",
                    location=self.contract_path,
                    line_number=i + 1,
                    code_snippet=self._get_code_snippet(i, 3),
                    recommendation="Only use delegatecall with trusted, immutable contracts. "
                                 "Never delegatecall to user-supplied addresses.",
                    reference="https://solidity-by-example.org/delegatecall/"
                ))
    
    def check_selfdestruct(self):
        """Detect selfdestruct usage"""
        for i, line in enumerate(self.lines):
            if 'selfdestruct' in line or 'suicide' in line:
                self.vulnerabilities.append(Vulnerability(
                    name="Selfdestruct Usage",
                    severity=Severity.HIGH,
                    description="Contract contains selfdestruct which can permanently destroy "
                              "the contract and send all funds to an address.",
                    location=self.contract_path,
                    line_number=i + 1,
                    code_snippet=self._get_code_snippet(i, 3),
                    recommendation="Ensure selfdestruct is properly protected and only callable "
                                 "by authorized addresses. Consider if it's necessary.",
                    reference="https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/self-destruct/"
                ))
    
    def check_locked_ether(self):
        """Detect contracts that can receive but not withdraw ether"""
        has_receive_fallback = False
        has_withdraw_function = False
        
        for line in self.lines:
            if 'receive() external payable' in line or 'fallback() external payable' in line:
                has_receive_fallback = True
            
            if 'function' in line and ('withdraw' in line.lower() or 'transfer' in line.lower()):
                has_withdraw_function = True
        
        if has_receive_fallback and not has_withdraw_function:
            self.vulnerabilities.append(Vulnerability(
                name="Locked Ether",
                severity=Severity.MEDIUM,
                description="Contract can receive Ether but has no function to withdraw it. "
                          "Ether sent to this contract will be locked forever.",
                location=self.contract_path,
                line_number=0,
                code_snippet="Contract accepts Ether via receive/fallback",
                recommendation="Add a withdraw function to allow retrieving Ether, "
                             "or remove the payable receive/fallback function.",
                reference="https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/locked-ether/"
            ))
    
    def check_integer_overflow(self):
        """Check for potential integer overflow issues (even with 0.8+)"""
        for i, line in enumerate(self.lines):
            # Look for unchecked blocks
            if 'unchecked' in line:
                self.vulnerabilities.append(Vulnerability(
                    name="Unchecked Arithmetic",
                    severity=Severity.HIGH,
                    description="Unchecked block disables overflow/underflow protection. "
                              "Arithmetic operations can silently wrap around.",
                    location=self.contract_path,
                    line_number=i + 1,
                    code_snippet=self._get_code_snippet(i, 5),
                    recommendation="Only use unchecked blocks when absolutely necessary "
                                 "for gas optimization and ensure values cannot overflow.",
                    reference="https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic"
                ))
    
    def _extract_function_name(self, line: str) -> str:
        """Extract function name from function declaration"""
        match = re.search(r'function\s+(\w+)', line)
        return match.group(1) if match else ""
    
    def _get_code_snippet(self, line_index: int, context: int = 3) -> str:
        """Get code snippet around the specified line"""
        start = max(0, line_index - context)
        end = min(len(self.lines), line_index + context + 1)
        
        snippet_lines = []
        for i in range(start, end):
            marker = ">>> " if i == line_index else "    "
            snippet_lines.append(f"{marker}{i + 1}: {self.lines[i]}")
        
        return '\n'.join(snippet_lines)


def analyze_contract(contract_path: str) -> List[Vulnerability]:
    """
    Analyze a Solidity contract for vulnerabilities
    
    Args:
        contract_path: Path to the Solidity contract file
        
    Returns:
        List of detected vulnerabilities
    """
    with open(contract_path, 'r', encoding='utf-8') as f:
        contract_code = f.read()
    
    detector = VulnerabilityDetector(contract_code, contract_path)
    return detector.detect_all()


if __name__ == "__main__":
    # Test the detector
    vulnerabilities = analyze_contract("tests/test_contracts/VulnerableContract.sol")
    
    print(f"\nüîç Secudity Vulnerability Scan Results\n")
    print(f"Found {len(vulnerabilities)} potential issues:\n")
    
    for vuln in vulnerabilities:
        print(f"[{vuln.severity.value}] {vuln.name}")
        print(f"  Line {vuln.line_number}: {vuln.description}")
        print(f"  Recommendation: {vuln.recommendation}\n")